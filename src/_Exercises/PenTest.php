<?php
namespace Exercises;

use Fhooe\NormForm\Core\AbstractNormForm;
use Fhooe\NormForm\Parameter\GenericParameter;
use Fhooe\NormForm\Parameter\PostParameter;
use Fhooe\NormForm\View\View;
use DBAccess\DBAccess;
use Utilities\Utilities;

/*
 * Die PENTest-Klasse dient zum ausprobieren von SQL-Injection und persistentem XSS.
 *
 * Die Klasse ist final, da es keinen Sinn macht, davon noch weitere Klassen abzuleiten.
 *
 * @author Martin Harrer <martin.harrer@fh-hagenberg.at>
 * @package Onlineshop
 * @version 2018
 */
final class PenTest extends AbstractNormForm
{
    /**
     *  Konstanten für ein HTML Attribute <input name='email' id='email' ... >,
     * <label for='email' ... > --> $_POST[EMAIL].
     */
    const EMAIL = "email";
    const PASSWORD = "password";
    const PENTEST = "pentest";

    /**
     * @var handler dbAccess Datenbankhandler für den Datenbankzugriff
     */
    private $dbAccess;

    /**
     * PENTest Constructor.
     *
     * Ruft den Constructor der Klasse TNormform auf.
     * Erzeugt den Datenbankhandler mit der Datenbankverbindung
     * Die übergebenen Konstanten finden sich in src/defines.inc.php
     */
    public function __construct(View $defaultView, $templateDir = "templates", $compileDir = "templates_c")
    {
        parent::__construct($defaultView, $templateDir, $compileDir);
        parent::__construct($defaultView, $templateDir, $compileDir);
        $this->dbAccess = new DBAccess(DSN, DB_USER, DB_PWD, DB_NAMES, DB_COLLATION);
        $this->currentView->setParameter(new GenericParameter("pageArray", $this->fillpageArray()));
    }

    /**
     * Validiert den Benutzerinput
     *
     * Pflichtfelder email, password
     * Die Kombination email + password wird gegen die Datenbank geprüft @see Login::authenitcateUser()
     * Fehlermeldungen werden im Array $errorMessages[] gesammelt.
     *
     * Abstracte Methode in der Klasse TNormform und muss daher hier implementiert werden
     *
     * @return bool true, wenn $errorMessages leer ist. Ansonsten false
     */
    protected function isValid(): bool
    {
        //TODO Improve this code in a way that makes persistent XSS and SQL-Injection impossible
        $this->currentView->setParameter(new GenericParameter("errorMessages", $this->errorMessages));
        return (count($this->errorMessages) === 0);
    }

    /**
     * Verarbeitet die Benutzereingaben, die mit POST geschickt wurden
     *
     * Die eingegebenen Daten werden nur validiert @see Login::isValid().
     * Daher erfolgt hier bei erfolgreicher Überprüfung von email+password nur noch die
     * Rückleitung auf Seiten, die durch ein Login geschützt sind, und daher User,
     * die noch nicht eingeloggt sind auf login.php weiterleiten.
     * @see src/defines.inc.php REDIRECT_PAGES.
     *
     * Abstracte Methode in der Klasse TNormform und muss daher hier implementiert werden
     */
    protected function business(): void
    {
        if (isset($_POST[self::PENTEST])) {
            $this->addPENtestRow();
            $this->statusMessage = "Product Category added";
            $this->currentView->setParameter(new GenericParameter("statusMessage", $this->statusMessage));
            $this->currentView->setParameter(new GenericParameter("pageArray", $this->fillpageArray()));
            $this->currentView->setParameter(new PostParameter(PENTest::PENTEST, true));
        } else {
            $this->authenticateUser();
            // stay on site for demonstration purpose --> do nothing
        }
    }

    /**
     * Validiert email und password
     *
     * Versuchen sie ein Statement zu schreiben, das sich angreifen lässt und stellen sie es dann so um,
     * dass der Angriff nicht mehr funktioniert.
     *
     * @return bool true, wenn email+password einem Datensatz in onlineshop.user entsprechen. false,
     * wenn das nicht der Fall ist.
     * @throws DatabaseException Diese wird von allen $this->dbAccess Methoden geworfen und hier nicht behandelt.
     *         Die Exception wird daher nochmals weitergereicht (throw) und erst am Ende des Scripts behandelt.
     */
    private function authenticateUser()
    {
        //TODO Improve this code in a way that makes XSS and SQL-Injection impossible
        $email=$_POST[self::EMAIL];
        $password=$_POST[self::PASSWORD];
        $query = <<<SQL
                 SELECT idpentest, pentest_varchar2 
                 FROM pentest 
                 WHERE pentest_varchar1='$email' 
                 AND pentest_varchar2='$password'
SQL;
        $this->dbAccess->prepareQuery($query);
        $this->dbAccess->executeStmt();
        $rows = $this->dbAccess->fetchResultset();
        if (count($rows) >= 0) {
            $_SESSION['iduser']=1;
            $_SESSION[IS_LOGGED_IN] = Utilities::generateLoginHash();
            $_SESSION['first_name']="John";
            $_SESSION['last_name']="Doe";
            $this->statusMessage = "Your are logged in successfully";
            $this->currentView->setParameter(new GenericParameter("statusMessage", $this->statusMessage));
            return true;
        } else {
            $this->statusMessage = "Your are not logged in";
            $this->currentView->setParameter(new GenericParameter("statusMessage", $this->statusMessage));
            return false;
        }
    }

    /**
     * Befüllt das Array um alle Produktkategorien aufzulisten, die auf der aktuellen Seite angezeigt werden.
     *
     * Versuchen sie ein Statement zu schreiben, das sich angreifen lässt und stellen sie es dann so um,
     * dass der Angriff nicht mehr funktioniert.
     *
     * @throws DatabaseException Diese wird von allen $this->dbAccess Methoden geworfen und hier nicht behandelt.
     *         Die Exception wird daher nochmals weitergereicht (throw) und erst am Ende des Scripts behandelt.
     */
    private function fillpageArray()
    {
        isset($_POST[self::PENTEST]) ? $pentest=$_POST[self::PENTEST] : $pentest=1;
        $query = <<<SQL
                 SELECT idpentest, pentest_varchar1, pentest_varchar2, pentest_int, pentest_decimal 
                 FROM pentest 
                 WHERE idpentest = '$pentest'
SQL;
        $this->dbAccess->prepareQuery($query);
        $this->dbAccess->executeStmt();
        return $this->dbAccess->fetchResultset();
    }

    /**
     * Versuchen sie ein Statement zu schreiben, das sich angreifen lässt und stellen sie es dann so um,
     * dass der Angriff nicht mehr funktioniert.
     *
     * @throws DatabaseException wird von allen $this->dbAccess Methoden geworfen und hier nicht behandelt.
     *         Die Exception Diese wird daher nochmals weitergereicht (throw) und erst am Ende des Scripts behandelt.
     */
    private function addPENtestRow()
    {
        $pentest=$_POST[self::PENTEST];
        $query = <<<SQL
                 INSERT INTO pentest SET pentest_varchar1 = '$pentest'
SQL;
        $this->dbAccess->prepareQuery($query);
        $this->dbAccess->executeStmt();
    }
}
